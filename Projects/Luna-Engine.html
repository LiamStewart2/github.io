<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://kit.fontawesome.com/56eea49a0b.js" crossorigin="anonymous"></script>
    <script src="../script.js"></script>
    <title>Luna Engine</title>
</head>
<body>
    <nav>
        <a href="../index.html" class="PP_back-button">Home</a>
        <a href="https://github.com/LiamStewart2/Luna-Engine" class="PP_github-button">GitHub</a>
    </nav>

    <main class="content">
        <section class="PP_project-introduction-section">
            <h1>Luna Engine</h1>
            <div class="seperation-line"></div>
            <p><i>Building a 3D Game Engine</i></p>
        </section>

        <section class="PP_project-overview">
            <video loop autoplay muted>
                <source src="../Assets/Videos/2025-07-06 02-43-17.mp4" type="video/mp4" />
                Your browser doesn't support the video tag.
            </video>

            <div class="PP_project-description">
                <p>This is my first attempt at building a 3D game engine using OpenGL. It is currently a work in progress, but i already have a couple features implemented forming the basis of the engine. This project is something i have wanted to commit to for a long time, and finally feel in a good position to start work on it.</p>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Entity Component System (ECS)</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/ECS_Simple_Layout.svg.png" alt="Git branching diagram" />
                        <p>This game engine will function on an <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a>, where game objects are just ID's that connect numerous components, using a database approach. This approach is far superior in terms of cache friendliness as the CPU can load the array of components as contiguous chunks of memory instead of individually grabbing each piece of data.</p>    
                        <p>These components are then used by whatever system needs them. For example, the Renderering System would need access to the Mesh Component and the Transform Component.</p>
                        <img src="../Assets/Photos/Rendering System.png">
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Cascading Shadow Mapping</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>My first goal with this game engine is to implement the graphical effects common in 99% of games now-days, and the first effect that came to mind was shadows. To achieve this effect i utilised <a href="https://en.wikipedia.org/wiki/Shadow_mapping">shadow mapping</a>, a technique where the scene is rendererd from the perspective of the light.</p>
                        <p>However, unlike when rendering the scene to the camera, we are only interested in the pixels distance from the camera, which is conviniently stored for us in the Z depth buffer. This buffer is then sampled to calculate whether the pixel currently being renderering in the shader is hidden from the light source or not.</p>
                        <img width = 300px src="../Assets/Photos/withShadowMapping.png"><img width = 300px src="../Assets/Photos/WithoutShadowMapping.png">
                        <p>Pure shadow mapping with no additional effects ontop however have a very costly increase in quality to performance ratio. If you want more defined shadows when zooming in close without having an insanely high resolution shadow buffer texture then a more complex method is required - <a href="https://learnopengl.com/Guest-Articles/2021/CSM">Cascading Shadow Mapping</a></p>
                        <p>CSM allows the lighting matricies to change depending on the distance between the camera and the given pixel, focusing the shadow buffer texture to the limits of the view frustum. This allows us to create higher quality shadows without increasing the resolution of the shadow textures. This effect is displayed by the different color filters on the video.</p>
                        <img src="../Assets/Photos/frustum_fitting.png">
                    </div>
                </div>

                
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Scene Graph</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>One of the latest features I added to my engine is a scene graph systemâ€”a way to organize objects hierarchically, so that child objects inherit transformations from their parents. I designed the system to store object IDs in a scene graph, which links to a Transformation Manager. Each frame, this manager walks through the graph to calculate and update the final world transforms for all objects.</p>
                        <img src="../Assets/Photos/SceneGraph ownership.png">
                    </div>
                </div>

        </section>
    </main>
</body>
</html>
