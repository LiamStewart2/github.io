<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://kit.fontawesome.com/56eea49a0b.js" crossorigin="anonymous"></script>
    <script src="../script.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title>Invasion Madness</title>
</head>
<body>
    <nav>
        <a href="../index.html" class="PP_back-button">Home</a>
    </nav>

    <main class="content">
        <section class="PP_project-introduction-section">
            <h1>Invasion Madness</h1>
            <div class="seperation-line"></div>
            <p><i>Adding Powerups to Space Invaders</i></p>
        </section>

        <section class="PP_project-overview">
            <video loop autoplay muted controls>
                <source src="../Assets/Videos/2025-06-19 04-59-47.mp4" type="video/mp4" />
                Your browser doesn't support the video tag.
            </video>

            <div class="PP_project-description">
                <p>This was my submition to the bespoke platform development module for year 1 of university, where we where tasked with building a cross platform game using C++ and SDL2 which would then be built onto a bespoke platform. For my game I decided to make a twist on the retro arcade game Space Invaders however with the addition of power ups. This project achieved a first class for the module.</p>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Cross Platform Development</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/evercade.png" alt="Evercade EXP console" style="max-width:500px;">
                        <p>The game was built onto an Evercade EXP, a handheld console designed for small retro games, with very restricting specifications. This meant that throughout development I was having to take the capabilities of the device into account.</p>    
                        <p>To build my game onto the evercade, I would go through the process of pushing all code onto a linux virtual machine then onto a buildserver. I would then push the compiled files onto the evercades cartridge and SSH into the device to run the game.</p>
                        <p>This was an amazing opportunity to get hands on experience building a cross platform game. I had previously used Unities build system to build a mobile game, however unities system abstracts most of the work from the developer, and it was interesting seeing how it works behind the scene.</p>
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Scene Manager</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>For this project, i built my first scene manager, capable of creating multiple "Scenes". A scene would be a child class of the parent scene class, having basic functions such as an Update, Render and HandleInput. These would be called by the owning SceneManager class to keep the game loop running.</p>
                        
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">class Scene
{
public:
	Scene(SDL_Window* _w, SDL_Renderer* _r) : window(_w), renderer(_r) {}
	~Scene() {}

	virtual void Init() = 0;
	virtual void Cleanup() = 0;

	virtual void Update() = 0;
	virtual void Render() = 0;
	virtual void HandleEvents() = 0;

protected:
	SDL_Window* window = nullptr;
	SDL_Renderer* renderer = nullptr;
};
</code></pre>
                        </div>
                        
                        <p>The scene manager class would use a <a href="https://en.wikipedia.org/wiki/Singleton">singleton</a>, allowing the instance to be accessible globally through the use of static functions. The scene manager contains a LoadScene function, allowing the developer to load any class derived from the Scene class. The scene instance is stored on the heap in the scene manager and isnt moved to prevent issues with memory management.</p>
                        <p>The scene manager then contains some "middle man" functions to run the scene from the application without having to interact with the scene instance itself.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">class SceneManager
{
public:
	SceneManager() {
		if(instance == nullptr)
			instance = this;
	}
	~SceneManager() { delete scene; }
	static SceneManager* instance;
	
	bool IsRunning() {return isRunning;}

	void UpdateScene();
	void RenderScene();
	void HandleSceneEvents();
	
	void LoadScene(Scene* _scene);
	void CloseApplication() {isRunning = false;}

	void SetJoystickReference(SDL_Joystick* joy) { joystick = joy; }
	SDL_Joystick* GetJoystick() { return joystick; }
private:
	bool isRunning = false;
	SDL_Joystick* joystick = nullptr;
	Scene* scene = nullptr;
};
</code></pre>
                        </div>
                        
                        <p>This allows the developer to load scene very intuitively and simply.</p>
                        
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">SceneManager::instance->LoadScene(new GameScene(window, renderer));
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Object Pooling</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>In this project, i implemented a reusable <a href="https://en.wikipedia.org/wiki/Object_pool_pattern">object pool</a> system using templates so that any object could be pooled. This sub-system was used for numerous features, such as the enemies, bullets and the particle effects.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">template &lt;class T>
class Object
{
public:
	Object(T* _data, int _ID) { data = _data; ID = _ID; }
	Object() {data = nullptr;}
	T* data;
	int ID = -1;
	bool inUse = false;
};

// Allocate on the heap to avoid issues with the linked list crashing
template &lt;class T>
class ObjectPool
{
public:
	ObjectPool() { InitPool(0); }
	ObjectPool(int estimatedMax) { InitPool(estimatedMax); }
	~ObjectPool() {}

	std::vector&lt;Object&lt;T>*>* GetObjects() { return &objectsInUse; }
	int GetNumberOfActiveObject() { return numberOfActiveObjects; }

	// returns the first free object
	// if no objects are free will add another object to the pool
	Object&lt;T>* GetFreeObject()
	{
		numberOfActiveObjects += 1;
		for (int i = likelyFirstAvailable; i < buffer.Size(); i++)
		{
			if (buffer[i].inUse == false)
			{
				buffer[i].inUse = true;
				likelyFirstAvailable = i;
				objectsInUse.push_back(&buffer[i]);
				return &buffer[i];
			}
		}
		// add new object to the buffer and remove later

   		Object&lt;T>* object = buffer.Push(Object&lt;T>(new T(), buffer.Size()));

		object->inUse = true;
		objectsInUse.push_back(object);
		likelyFirstAvailable = buffer.Size() - 1;
		

		return object;
	}

	// will disable the object and remove it from the objects in use list
	void DisableObject(Object&lt;T>* object)
	{
		numberOfActiveObjects -= 1;
		if(object->ID < likelyFirstAvailable)
			likelyFirstAvailable = object->ID;
		buffer[object->ID].inUse = false;
		
		for (int i = 0; i < objectsInUse.size(); i++)
		{
			if (objectsInUse[i]->ID == object->ID)
			{
				objectsInUse.erase(objectsInUse.begin() + i);
				return;
			}
		}
	}

private:
	// object buffer uses a linked list so that memory doesnt move when expanding
	LinkedList&lt;Object&lt;T>> buffer;

	// track the objects currently enabled to handle Update and Render calls
	std::vector&lt;Object&lt;T>*> objectsInUse;

	// keeps track of the rough first available object
	// atleast tells us the rough area of where the algorithm should start looking for an unused object
	int likelyFirstAvailable = 0;

	int numberOfActiveObjects = 0;

	void InitPool(int size)
	{
		for (int i = 0; i < size; i++)
			buffer.Push(Object&lt;T>(new T(), i));
	}
};
</code></pre>
                        </div>
                        <p>The implementation uses a <a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a> of object instances. Objects store "data" of type T, using templates letting us change what we are storing in each object pool. I then have numerous functions to manage this linked list, such as getting the next available object, disabling a certain object, or initializing the pool itself.</p>
                        <p>An optimisation of mine on top of the regular object pool was tracking where the first free to use object would be stored. This takes the expensive linear search algorithm which had a worse, and very common, case of o(n) time complexity. The optimised version is closer to an o(1) time complexity.</p>
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Retrospective</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>This project was my first time using docker tools and operating build servers to build my games to other platforms, and was a fun task to work on, seeing my game on handheld devices.</p>
                        <p>One issue i encountered during the development of this project was not checking the compatability of libraries i used. Initially, i used JSON files to store data about my particle systems, however realised on the last week of development that <a href="https://github.com/nlohmann/json">Nlohmann's JSON library</a> wasn't compatible on the linux platform so had to rebuild the system using much simpler, C++ standard file reading.</p>
                    </div>
                </div>

            </div>
        </section>
    </main>
</body>
</html>
