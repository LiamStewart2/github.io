<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles.css">
    <script src="https://kit.fontawesome.com/56eea49a0b.js" crossorigin="anonymous"></script>
    <script src="../script.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title>Voxel Renderer</title>
</head>
<body>
    <nav>
        <a href="../index.html" class="PP_back-button">Home</a>
        <a href="https://github.com/LiamStewart2/Minecraft-Recreation" class="PP_github-button">Github</a>
    </nav>
    <div class="content">
        <div class="PP_project-introduction-section">
            <h1>Voxel Renderer</h1>
            <div class="seperation-line"></div>
            <p><i>Recreating the Minecraft Renderer</i></p>
        </div>


        <div class="PP_project-overview">
            <video loop autoplay muted>
                <source src="../Assets/Videos/2025-05-15 13-25-44.mp4" type="video/mp4">
                Your browser doesnt support the video tag
            </video>
            <div class="PP_project-description">
                <p>This was my second attempt at a voxel renderer using C++ and OpenGL. My first version lacked structure, performance, and proper architectural design. For this second attempt, I thoroughly researched the topic of voxels beforehand and properly planned how I wished to architect the project.</p>
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Solution</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>In my first system, each block was its own mesh. Whilst hidden faces where still culled, the renderer still issued thousands of draw calls a frame - an inefficient approach as modern GPU's are optimized for fewer, larger draw calls.</p>
                        <p>This new system bakes the mesh of each chunk at the start of run time instead. All mesh chunks are then rendered together, reducing the thousands of render calls to more like 32 or 64, depending on the render distance set in the configuration.</p>
                        <img src="../Assets/Photos/Voxel-Renderer-Diagram.png">
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Texture Atlas</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/blockAtlas.png">    
                        <p>Another system implemented in this version is a <a href="https://en.wikipedia.org/wiki/Texture_atlas">texture atlas</a>. This means each face of the mesh can be rendered without needing to take breaks for different voxel types.</p>
                        <p>To use this, the texture coordinates of each block would be fetched from the texture atlas instance and pushed to the chunk's mesh.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">chunkMesh.loadMeshData(&FaceData::TOP, glm::vec3(x, y, z), textureAtlas->getTextureCoordinateOffset(currentBlock->topTexture));
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Terrain Generation</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>The generated terrain uses a <a href="https://en.wikipedia.org/wiki/Perlin_noise">perlin noise</a> implementation to span very large distances without the need for manually building a map. I took a similar approach to Minecraft when it came to using perlin noise, where multiple different layers of perlin noise are used on top of each other.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">void Chunk::generateTerrain(PerlinNoise* terrainGenerationNoise)
{
	for (int x = 0; x < config::chunkWidth; x++)
	{
		for (int z = 0; z < config::chunkHeight; z++)
		{
			glm::vec3 blockWorldPosition = getBlockWorldPosition(glm::vec3(x, 0, z));

			// is offset to aboid perlin noise borders - the player has to travel 128 chunks to find a perlin noise border
			double heightValue = terrainGenerationNoise->octaveNoise((blockWorldPosition.x + config::chunkWidth * 128) / (config::chunkWidth * 1.5f), (blockWorldPosition.z + config::chunkHeight * 128) / (config::chunkHeight * 1.5f), 3, 0.6);
			double crazyValue = terrainGenerationNoise->octaveNoise((blockWorldPosition.x + config::chunkWidth * 128) / (config::chunkWidth * 1.5f), (blockWorldPosition.z + config::chunkHeight * 128) / (config::chunkHeight * 1.5f), 2, 0.004);

			int height = (config::chunkHeight / 2) + static_cast&lt;int>((config::chunkHeight * heightValue * ((crazyValue + 1))));


			for (int y = 0; y < config::chunkLayers; y++)
			{
				int index = getIndexFromRelativePosition(x, y, z);


				if (y == height)
					blockBuffer[index] = &BlockDatabase::Grass;
				else if(y < height)
					blockBuffer[index] = &BlockDatabase::Dirt;
				else
					blockBuffer[index] = &BlockDatabase::Air;
			}
		}
	}
}
</code></pre>
                        </div>
                        <p>This is a very simple usage of perlin noise, and has the issue where a border is formed every 128 chunks, however, the generation still expands infinitely, essentially looping the generated terrain there onwards.</p>
                    </div>
                </div>

                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Retrospective</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>If I were to work on this project further, the first change I would work on would be the addition of trees. My first attempt did have trees; however, they were done in a way where they weren't consistent, using the built-in rand function to determine where to place them. They were also very simply implemented, always having the same shape. Preferably, I would want a more procedural approach.</p>
                        <p>Overall, this project served as a strong improvement over my previous work, allowing me to refine my OpenGL skills and gain a better understanding of procedural generation techniques.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>