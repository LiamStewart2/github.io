<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://kit.fontawesome.com/56eea49a0b.js" crossorigin="anonymous"></script>
    <script src="../script.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title>RTS Engine Project</title>
</head>
<body>
    <nav>
        <a href="../index.html" class="PP_back-button">Home</a>
    </nav>

    <main class="content">
        <section class="PP_project-introduction-section">
            <h1>RTS Engine</h1>
            <div class="seperation-line"></div>
            <p><i>Creating a lightweight RTS engine</i></p>
        </section>

        <section class="PP_project-overview">
            <video loop autoplay muted controls>
                <source src="../Assets/Videos/2025-05-26 17-31-58.mp4" type="video/mp4" />
                Your browser doesn't support the video tag.
            </video>

            <div class="PP_project-description">
                <p>For this project, I volunteered, collaborating with a team of 6 developers using C++ and SFML to build an RTS game engine. I was responsible for the agents and rendering systems, working closely with the engine core to optimise and implement new features.</p>

                <!-- GitHub Section -->
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>GitHub</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/Branch.png" alt="Git branching diagram" />
                        <p>As this was my first group project, it was also my first time using Git's collaboration features. Our team used <a href="https://github.com/">GitHub</a> to host the repository, with each contributor working in a separate branch.</p>
                        <p>I spent the first few weeks learning Git in-depth—getting familiar with key commands, resolving merge conflicts, and organizing branch structures for team efficiency.</p>
                    </div>
                </div>

                <!-- Agents Section -->
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Agents</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/baronTemp (2).png" alt="Plane agent in-game screenshot" />
                        <p>My first major task was developing the agent system. The system consisted of two main parts: the agents themselves and an Agent Manager. While the implementation evolved over time, the core idea—using inheritance to represent all world entities—remained constant.</p>
                        <p>Every object in the world (trees, planes, future structures) was treated as an agent. Some could move, others were static, and each required unique behavior. To support this variety, I implemented an inheritance-based class hierarchy.</p>
                        <img src="../Assets/Photos/RTS-Agents-Diagram.png" alt="Agent inheritance diagram" />
                        <p>Agents were stored in a <a href="https://en.wikipedia.org/wiki/Quadtree">quadtree</a> structure developed by another programmer, which allowed for efficient spatial queries during rendering and updates.</p>
                        
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">void AgentManager::PlaceMobileAgent(sf::Vector2i cell, std::set&lt;std::vector&lt;BattlefieldCell>::iterator>* gameScene, MobileAgent, agent, GameStateManager& gamestateManager)
{
    MobileAgent* newAgent = new MobileAgent(agent);
    
    gamestateManager.getState().Units.push_back(newAgent);
    gamestateManager.getState().Quadtree->Insert(newAgent, constants.CELL_SIZE);

    mobileAgent.push_back(newAgent);
}
</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Isometric Terrain Section -->
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Isometric Terrain</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <img src="../Assets/Photos/grass_spritesheet.png" alt="Grass tile spritesheet" />
                        <p>I was also responsible for the isometric terrain system. While utility functions already existed to convert between world and screen space, we needed a system to associate terrain tiles in the quadtree with their texture data.</p>
                        <p>We used a combination of JSON files and a Python tool to procedurally generate maps. These files included both terrain height and type arrays.</p>
                        <p>Loading the height map:</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">void BattlefieldMap::initDepthMap()
{
    depthMap = new int* [size];
    
    for (int i = 0; i &lt; size; i++)
    {
        depthMap[i] = new int[size];
        for (int j = 0; j &lt; size; j++)
        {
            depthMap[i][j] = imin(mapData["MapData"]["HeightMap"][i][j], GlobalConstants::maxMapHeight);
        }
    }
}
</code></pre>
                        </div>
                        
                        <p>For terrain types, I used a hash map that linked terrain keys in the JSON to corresponding spritesheets, allowing flexible and extensible terrain rendering.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">void BattlefieldMap::initTerrainMap() {
    terrainMap = new TerrainInstance * [size];
    for (int i = 0; i &lt; size; ++i) {
        terrainMap[i] = new TerrainInstance[size];
        for (int j = 0; j &lt; size; ++j) {
            std::string terrainKey = mapData["MapData"]["TerrainMap"][i][j];
            std::string thisTerrainTypeName;

            if (mapData["MapData"]["RequiredTerrainTypes"].contains(terrainKey)) {
                thisTerrainTypeName = mapData["MapData"]["RequiredTerrainTypes"][terrainKey];
            }
            else {
                std::cerr &lt;&lt; "Unknown terrain type key: " &lt;&lt; terrainKey &lt;&lt; std::endl;
                continue;
            }

            bool found = false;
            for (const auto& terrainType : terrainTypes) {
                if (terrainType.name == thisTerrainTypeName) {
                    terrainMap[i][j] = TerrainInstance(terrainType);
                    found = true;
                    break;
                }
            }

            if (!found) {
                std::cerr &lt;&lt; "Unknown terrain type name: " &lt;&lt; thisTerrainTypeName &lt;&lt; std::endl;
            }
        }
    }

    for (int y = 0; y &lt; size; ++y) {
        for (int x = 0; x &lt; size; ++x) {
            terrainMap[y][x].setSpriteIndex(directionMap[y][x]);
        }
    }

    SpriteManager::GetInstance()->SetRequiredTerrainSpriteSheetList(terrainMap, size);
}
</code></pre>
                        </div>

                        <p>To determine which tile to use from the spritesheet, I evaluated the height of neighboring tiles to pick the correct directional variant. Most of this logic is implemented through conditional statements.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">void BattlefieldMap::initDirectionMap()
{
    directionMap = new Direction*[size];

    for (int i = 0; i < size; i++)
    {
        directionMap[i] = new Direction[size];
        for (int j = 0; j < size; j++)
        {
            /////////////////////////////
            // Peak Mountain Checks
            /////////////////////////////
            if ((i > 0 && i < size - 1 && j > 0 && j < size - 1) && (depthMap[i - 1][j] < depthMap[i][j] && depthMap[i][j - 1] < depthMap[i][j] && depthMap[i + 1][j] < depthMap[i][j] && depthMap[i][j + 1] < depthMap[i][j]))
                directionMap[i][j] = P;
            else if ((i == 0 && j == 0) && (depthMap[i + 1][j] < depthMap[i][j] && depthMap[i][j + 1] < depthMap[i][j]))
                directionMap[i][j] = P;
            //...

            /////////////////////////////
            // Inward angle checks
            /////////////////////////////
            else if (i > 0 && j < size - 1 && (depthMap[i - 1][j] > depthMap[i][j] && depthMap[i][j + 1] > depthMap[i][j]))
                directionMap[i][j] = NIW;
            else if (i < size - 1 && j < size - 1 &&
                     (depthMap[i + 1][j] > depthMap[i][j] && depthMap[i][j + 1] > depthMap[i][j]))
                directionMap[i][j] = NIE;
            //...
        }
    }
}
</code></pre>
                        </div>

                        <p>If I were to rebuild the terrain system, I would likely switch to an orthographic 3D approach using a mesh generated from heightmaps, with texture blending for smoother terrain transitions.</p>
                    </div>
                </div>

                <!-- Boids Section -->
                <div class="PP_project-section">
                    <div class="PP_project-section-title">
                        <h3><u>Boids</u></h3>
                        <i class="fa-solid fa-chevron-down"></i>
                    </div>
                    <div class="PP_project-description-content">
                        <p>As shown in the video, multiple planes follow a lead plane using a combination of <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* pathfinding</a> and <a href="https://en.wikipedia.org/wiki/Boids">boids</a> behavior. While another programmer worked on pathfinding, I implemented the boids behavior.</p>
                        <div class="PP_project-code-snippet">
<pre><code class="language-cpp">class MobileAgent : public Agent
{
public:
	MobileAgent(...) : Agent(...) 
    { 
        lastCellPosition = sf::Vector2i(initialPosX, initialPosY); 
        isMobileAgent = true; 
    }

	void update(GameStateManager* gameStateManager);
private:
	std::vector<Agent*> nearbyAgents;
	sf::Vector2f velocity;
	PathfinderAgent* pathfinderAgent = nullptr;

	void Coherence();
	void seperation();
	void Alignment();

	//... Other members
};
</code></pre>
                        </div>
                        
                        <p>The boids were implemented as specialized agents with AI logic. They followed a PathfinderAgent using simple separation, alignment, and cohesion rules.</p>
                        <p>Unfortunately, we ran out of development time before adding formation logic. If I continue working on the project, I'd expand the system to support formations—common in RTS games—where boids organize into predefined layouts during movement.</p>
                    </div>
                </div>
            </div>
        </section>
    </main>
</body>
</html>
